caterwaul.clone('std continuation seq parser')(function () {
  tagparser = peg[[text]],
  where*[
    // Forward definitions to allow first-class circular references
    text(x)        = text(x),
    metadata(x)    = metadata(x),
    not_special(x) = not_special(x),

    whitespace     = peg[c(/\s+/, 1) >> fn[xs][xs[0]]],

    not_special    = l[bracketed_case = peg[c('[') % not_special % c(']') >> fn[xs]['[#{xs[1]}]']],
                       text_case      = peg[c(/[^@\s\|\[\]]/, 1)[1] >> fn[xs][seq[~xs *[_[0]]].join('')]],
                       escaped_case   = peg[c(/\\(.)/, 2) >> fn[xs][xs[1]]]] in
                     peg[([whitespace] % (bracketed_case / text_case / escaped_case))[1] >> fn[xs][seq[~xs *[(_[0] || '') + _[1]]].join('')]],

    label          = peg[c(/@(\w+)/, 2) >> fn[xs][{name: xs[1], data: false, metadata: false}]],
    tag            = peg[label % c('[') % [text] % [whitespace] % [c('|') % metadata % [whitespace]] % c(']') >>
                         fn[xs][{name: xs[0].name, data: xs[2], metadata: xs[4] /re[_ && _[1]]}]],

    metadata       = peg[([whitespace] % (tag / label) >> fn[xs][xs[1]])[0]],

    block          = peg[(c('@[') % reject(c('/'))) % text % [whitespace] % [c('|') % metadata % [whitespace]] % c(']') % [text] % [whitespace] %
                        ((c('@/')                  >> fn_[null]) /
                         (c('@[/') % text % c(']') >> fn[xs][xs[1]])) >>
                         fn[xs][unwind['Expected closing tag for #{xs[1].join("")} but got #{xs[7].join("")} instead'], when[xs[7] && xs[7].join('') !== xs[1].join('')],
                                {name: xs[1], metadata: xs[3] /re[_ && _[1]], data: xs[5] /re[xs[6] ? _.concat(xs[6]) : _]}]],

                     // Whitespace hackery to avoid munching the spaces before a |; e.g. @foo[bar | @bif] should contain 'bar', not 'bar '.
    text           = peg[([whitespace] % (block / tag / label / not_special))[1] >> fn[xs][seq[(~xs -[_]) %[_ !== false]].slice()]]]})();
// Generated by SDoc 
