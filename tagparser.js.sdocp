sdocp('sdoc::js::tagparser', 'caterwaul.clone(\'std continuation seq parser\')(function () {\n  tagparser = peg[[text]],\n  where*[\n    // Forward definitions to allow first-class circular references\n    text(x)        = text(x),\n    metadata(x)    = metadata(x),\n    not_special(x) = not_special(x),\n\n    whitespace     = peg[c(/\\s+/, 1) >> fn[xs][xs[0]]],\n\n    not_special    = l[bracketed_case = peg[c(\'[\') % not_special % c(\']\') >> fn[xs][\'[#{xs[1]}]\']],\n                       text_case      = peg[c(/[^@\\s\\|\\[\\]]/, 1)[1] >> fn[xs][seq[~xs *[_[0]]].join(\'\')]],\n                       escaped_case   = peg[c(/\\\\(.)/, 2) >> fn[xs][xs[1]]]] in\n                     peg[([whitespace] % (bracketed_case / text_case / escaped_case))[1] >> fn[xs][seq[~xs *[(_[0] || \'\') + _[1]]].join(\'\')]],\n\n    label          = peg[c(/@(\\w+)/, 2) >> fn[xs][{name: xs[1], data: false, metadata: false}]],\n    tag            = peg[label % c(\'[\') % [text] % [whitespace] % [c(\'|\') % metadata % [whitespace]] % c(\']\') >>\n                         fn[xs][{name: xs[0].name, data: xs[2], metadata: xs[4] /re[_ && _[1]]}]],\n\n    metadata       = peg[([whitespace] % (tag / label) >> fn[xs][xs[1]])[0]],\n\n    block          = peg[c(\'@[\') % text % [whitespace] % [c(\'|\') % metadata % [whitespace]] % c(\']\') % [text] % [whitespace] % c(\'@[]\') >>\n                         fn[xs][{name: xs[1], metadata: xs[3] /re[_ && _[1]], data: xs[5] /re[xs[6] ? _.concat(xs[6]) : _]}]],\n\n                     // Whitespace hackery to avoid munching the spaces before a |; e.g. @foo[bar | @bif] should contain \'bar\', not \'bar \'.\n    text           = peg[([whitespace] % (block / tag / label / not_special))[1] >> fn[xs][seq[(~xs -[_]) %[_ !== false]].slice()]]]})();');